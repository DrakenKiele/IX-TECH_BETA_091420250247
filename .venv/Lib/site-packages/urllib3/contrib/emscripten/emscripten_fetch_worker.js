// # BREADCRUMB: [Project/Module] > emscripten_fetch_worker.js
// # This file is the root entry point and orchestrator for the entire system.
// # Next files in program flow (launch order):
// #   1. [next_file_1] ([how_it_is_invoked_or_launched])
// #   2. [next_file_2] ([how_it_is_invoked_or_launched])
// #   3. [next_file_3] ([how_it_is_invoked_or_launched])
// #   ...
// # (Replace with actual files and launch details for each file.)
// # -----------------------------------------------------------------------------
// # File: emscripten_fetch_worker.js
// # Purpose: Central entry point and orchestrator for the system.
// #
// # Type: Main launcher script (not a class file, but acts as a system controller)
// #
// # Responsibilities:
// #   - Loads configuration and resolves paths for all major dependencies ([List dependencies])
// #   - Checks and manages the status of critical services (starts/stops as needed)
// #   - Launches and monitors all core services:
// #       * [Service 1] ([Tech/Port])
// #       * [Service 2] ([Tech/Port])
// #       * [Service 3] ([Tech/Port])
// #       * [Service 4] ([Tech/Port])
// #   - Provides command-line flags for status reporting and service termination ([flags])
// #   - Handles process cleanup and error reporting
// #
// # Key Functions:
// #   - main(): Orchestrates the full launch sequence and handles CLI flags
// #   - launch_service(): Starts a subprocess for a given service
// #   - stream_logs(): Streams and truncates logs from subprocesses
// #   - run_static_server(): Runs the static file server (if applicable)
// #   - is_port_in_use(): Checks if a TCP port is active
// #   - get_service_status(): Returns a dict of service statuses
// #   - check_service(): Ensures a service is running, starts if not
// #   - resolve_path(): Finds the first valid path for a dependency from config
// #   - find_dependency_path(): Locates the executable for a dependency
// #
// # Relationships:
// #   - Reads from configuration files for dependency paths
// #   - Launches and monitors other scripts and processes
// #   - Interacts with the OS for process and port management
// #
// # Usefulness & Execution Path:
// #   - main() is the required entry point and is always used.
// #   - [List of essential functions] are all actively used and essential for orchestrating the system.
// #   - [Legacy/optional functions] may become obsolete as the system evolves.
// #
// # Suggestions:
// #   - **Performance:** [Performance notes]
// #   - **Code Cleanliness:** [Code cleanliness notes]
// #   - **Location:** [Location notes]
// #   - **Function:** [Function notes]
// #   - **Legacy:** [Legacy notes]
// #   - **Config:** [Config notes]
// #   - **Error Handling:** [Error handling notes]
// #   - **Cross-Platform:** [Cross-platform notes]
// #
// # Summary:
// #   - This file is essential, well-placed, and mostly clean.
// #   - All major functions are used and support the requirements for modularity, orchestration, and portability.
// #   - Minor cleanup (removing redundant code, legacy functions) is recommended to enhance maintainability.
// #   - Overall, it effectively serves as the central controller for the system.
// #
// # CHANGE MANAGEMENT LOG
// # Date        | Initials | Description of Change                | Reason for Change
// # -----------------------------------------------------------------------------
// # 2025-09-05 | [XX]    | [Description]                        | [Reason]
// # -----------------------------------------------------------------------------
// 
let Status = {
  SUCCESS_HEADER: -1,
  SUCCESS_EOF: -2,
  ERROR_TIMEOUT: -3,
  ERROR_EXCEPTION: -4,
};

let connections = {};
let nextConnectionID = 1;
const encoder = new TextEncoder();

self.addEventListener("message", async function (event) {
  if (event.data.close) {
    let connectionID = event.data.close;
    delete connections[connectionID];
    return;
  } else if (event.data.getMore) {
    let connectionID = event.data.getMore;
    let { curOffset, value, reader, intBuffer, byteBuffer } =
      connections[connectionID];
    // if we still have some in buffer, then just send it back straight away
    if (!value || curOffset >= value.length) {
      // read another buffer if required
      try {
        let readResponse = await reader.read();

        if (readResponse.done) {
          // read everything - clear connection and return
          delete connections[connectionID];
          Atomics.store(intBuffer, 0, Status.SUCCESS_EOF);
          Atomics.notify(intBuffer, 0);
          // finished reading successfully
          // return from event handler
          return;
        }
        curOffset = 0;
        connections[connectionID].value = readResponse.value;
        value = readResponse.value;
      } catch (error) {
        console.log("Request exception:", error);
        let errorBytes = encoder.encode(error.message);
        let written = errorBytes.length;
        byteBuffer.set(errorBytes);
        intBuffer[1] = written;
        Atomics.store(intBuffer, 0, Status.ERROR_EXCEPTION);
        Atomics.notify(intBuffer, 0);
      }
    }

    // send as much buffer as we can
    let curLen = value.length - curOffset;
    if (curLen > byteBuffer.length) {
      curLen = byteBuffer.length;
    }
    byteBuffer.set(value.subarray(curOffset, curOffset + curLen), 0);

    Atomics.store(intBuffer, 0, curLen); // store current length in bytes
    Atomics.notify(intBuffer, 0);
    curOffset += curLen;
    connections[connectionID].curOffset = curOffset;

    return;
  } else {
    // start fetch
    let connectionID = nextConnectionID;
    nextConnectionID += 1;
    const intBuffer = new Int32Array(event.data.buffer);
    const byteBuffer = new Uint8Array(event.data.buffer, 8);
    try {
      const response = await fetch(event.data.url, event.data.fetchParams);
      // return the headers first via textencoder
      var headers = [];
      for (const pair of response.headers.entries()) {
        headers.push([pair[0], pair[1]]);
      }
      let headerObj = {
        headers: headers,
        status: response.status,
        connectionID,
      };
      const headerText = JSON.stringify(headerObj);
      let headerBytes = encoder.encode(headerText);
      let written = headerBytes.length;
      byteBuffer.set(headerBytes);
      intBuffer[1] = written;
      // make a connection
      connections[connectionID] = {
        reader: response.body.getReader(),
        intBuffer: intBuffer,
        byteBuffer: byteBuffer,
        value: undefined,
        curOffset: 0,
      };
      // set header ready
      Atomics.store(intBuffer, 0, Status.SUCCESS_HEADER);
      Atomics.notify(intBuffer, 0);
      // all fetching after this goes through a new postmessage call with getMore
      // this allows for parallel requests
    } catch (error) {
      console.log("Request exception:", error);
      let errorBytes = encoder.encode(error.message);
      let written = errorBytes.length;
      byteBuffer.set(errorBytes);
      intBuffer[1] = written;
      Atomics.store(intBuffer, 0, Status.ERROR_EXCEPTION);
      Atomics.notify(intBuffer, 0);
    }
  }
});
self.postMessage({ inited: true });
