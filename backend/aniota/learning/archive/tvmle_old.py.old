"""
TVMLE - Triadic Vector Mathematical Learning Engine
Minimal implementation to prove mathematical consciousness concept

Converts micro-events (mouse, keyboard, clipboard) into triadic vectors
and performs mathematical correlation analysis for learning patterns.
"""

from typing import Dict, List, Any, Optional, Tuple
from datetime import datetime
import math
from ..base_module import CoreSystemModule


class TriadicVector:
    """
    Represents a micro-event as a triadic vector:
    - temporal: (start_time, end_time, duration)
    - radial: distance from root knowledge
    - spatial: (x_study_area, y_context)
    """
    def __init__(self, temporal: Tuple[float, float, float], 
                 radial: float, spatial: Tuple[float, float]):
        self.temporal = temporal  # (start, end, duration)
        self.radial = radial      # distance from root knowledge
        self.spatial = spatial    # (x, y) coordinates in learning space
        self.timestamp = datetime.now()
        
    def correlation_with(self, other_vector) -> float:
        """Calculate mathematical correlation between two triadic vectors"""
        # Simple correlation: smaller difference = higher correlation
        temporal_diff = abs(self.temporal[2] - other_vector.temporal[2])  # duration difference
        radial_diff = abs(self.radial - other_vector.radial)
        spatial_diff = math.sqrt(
            (self.spatial[0] - other_vector.spatial[0])**2 + 
            (self.spatial[1] - other_vector.spatial[1])**2
        )
        
        # Normalize to 0-1 correlation score (1 = perfect match)
        total_diff = temporal_diff + radial_diff + spatial_diff
        correlation = 1.0 / (1.0 + total_diff)
        return correlation

class TriadicVectorMathematicalLearningEngine(CoreSystemModule):
    """
    TVMLE - Minimal mathematical learning engine
    
    Converts micro-events into triadic vectors and learns through
    mathematical correlation analysis rather than traditional ML.
    """
    
    def __init__(self, parent=None):
        super().__init__("TVMLE", parent)
        
        # Vector storage
        self.learned_vectors: List[TriadicVector] = []
        self.correlation_threshold = 0.75  # High correlation threshold
        
        # Learning statistics
        self.total_events = 0
        self.recognized_patterns = 0
        self.new_patterns_learned = 0
        
    def process_mouse_event(self, event_data: Dict[str, Any]) -> Optional[TriadicVector]:
        """Convert mouse event into triadic vector"""
        try:
            # Extract timing data
            start_time = event_data.get('start_time', 0)
            end_time = event_data.get('end_time', 0)
            duration = end_time - start_time
            
            # Calculate radial distance (complexity from root)
            # Simple heuristic: longer hesitation = more complex decision
            radial = min(duration / 10.0, 1.0)  # Normalize to 0-1
            
            # Extract spatial coordinates
            x_pos = event_data.get('x', 0) / 1000.0  # Normalize screen position
            y_pos = event_data.get('y', 0) / 1000.0
            
            vector = TriadicVector(
                temporal=(start_time, end_time, duration),
                radial=radial,
                spatial=(x_pos, y_pos)
            )
            
            return self._learn_from_vector(vector)
            
        except Exception as e:
            self.logger.error(f"Error processing mouse event: {e}")
            return None
    
    def process_keyboard_event(self, event_data: Dict[str, Any]) -> Optional[TriadicVector]:
        """Convert keyboard event into triadic vector"""
        try:
            # Extract timing between keystrokes
            interval = event_data.get('interval', 0)
            key_type = event_data.get('key_type', 'letter')
            
            # Radial distance based on typing complexity
            radial_mapping = {
                'letter': 0.1,
                'number': 0.3,
                'symbol': 0.5,
                'function': 0.8
            }
            radial = radial_mapping.get(key_type, 0.5)
            
            # Spatial coordinates based on typing pattern
            x_coord = interval / 1000.0  # Normalize interval
            y_coord = len(event_data.get('sequence', '')) / 10.0  # Sequence length
            
            vector = TriadicVector(
                temporal=(0, interval, interval),
                radial=radial,
                spatial=(x_coord, y_coord)
            )
            
            return self._learn_from_vector(vector)
            
        except Exception as e:
            self.logger.error(f"Error processing keyboard event: {e}")
            return None
    
    def process_clipboard_event(self, event_data: Dict[str, Any]) -> Optional[TriadicVector]:
        """Convert clipboard event into triadic vector"""
        try:
            action = event_data.get('action', 'copy')  # copy, paste, cut
            duration = event_data.get('duration', 0)
            content_length = event_data.get('content_length', 0)
            
            # Radial distance based on clipboard complexity
            radial = min(content_length / 100.0, 1.0)
            
            # Spatial coordinates
            action_mapping = {'copy': 0.2, 'paste': 0.5, 'cut': 0.8}
            x_coord = action_mapping.get(action, 0.5)
            y_coord = duration / 1000.0
            
            vector = TriadicVector(
                temporal=(0, duration, duration),
                radial=radial,
                spatial=(x_coord, y_coord)
            )
            
            return self._learn_from_vector(vector)
            
        except Exception as e:
            self.logger.error(f"Error processing clipboard event: {e}")
            return None
    
    def _learn_from_vector(self, new_vector: TriadicVector) -> TriadicVector:
        """Core learning logic: compare vector with existing patterns"""
        self.total_events += 1
        
        # Find highest correlation with existing vectors
        best_correlation = 0.0
        best_match = None
        
        for existing_vector in self.learned_vectors:
            correlation = new_vector.correlation_with(existing_vector)
            if correlation > best_correlation:
                best_correlation = correlation
                best_match = existing_vector
        
        # Learning decision
        if best_correlation >= self.correlation_threshold:
            # Recognized pattern
            self.recognized_patterns += 1
            self.logger.info(f"Pattern recognized with {best_correlation:.3f} correlation")
        else:
            # New pattern - learn it
            self.learned_vectors.append(new_vector)
            self.new_patterns_learned += 1
            self.logger.info(f"New pattern learned. Total patterns: {len(self.learned_vectors)}")
        
        return new_vector
    
    def get_learning_stats(self) -> Dict[str, Any]:
        """Return current learning statistics"""
        return {
            'total_events': self.total_events,
            'recognized_patterns': self.recognized_patterns,
            'new_patterns_learned': self.new_patterns_learned,
            'total_learned_vectors': len(self.learned_vectors),
            'recognition_rate': self.recognized_patterns / max(self.total_events, 1),
            'learning_rate': self.new_patterns_learned / max(self.total_events, 1)
        }
    
    def explain_learning(self, vector: TriadicVector) -> str:
        """Explain the mathematical reasoning behind a learning decision"""
        correlations = []
        for existing_vector in self.learned_vectors[:5]:  # Show top 5
            correlation = vector.correlation_with(existing_vector)
            correlations.append(f"Vector correlation: {correlation:.3f}")
        
        explanation = f"""
Mathematical Learning Analysis:
Vector: temporal={vector.temporal[2]:.2f}s, radial={vector.radial:.2f}, spatial=({vector.spatial[0]:.2f}, {vector.spatial[1]:.2f})
Correlations with existing patterns:
{chr(10).join(correlations[:3])}
Decision: {'Recognized' if max([v.correlation_with(vector) for v in self.learned_vectors] + [0]) >= self.correlation_threshold else 'New pattern learned'}
        """
        return explanation.strip()
